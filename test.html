<html>
<head>
  <style>
    html, body {
      width:  100%;
      height: 100%;
      margin: 0;
    }

    #controls {
      position: absolute;
      top: 10;
      left: 10;
      z-index: 1;
    }

    #shapeEditor {
      background-color: lightgrey;
    }

    #controls button, #shapeEditor button, #shapeEditor label, #shapeEditor input {
      display: block;
    }
  </style>

  <link rel="manifest" href="site.webmanifest" />
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="mask-icon" href="favicon.ico" color="#000000">
</head>
<body>
  <div id="controls">
    <button onclick="placeCharacter()" id="placeCharacter" disabled=true>place character</button>
    <button onclick="makeShapes()" id="makeShapes" disabled=true>make shapes</button>
    <button onclick="editShapes()" id="editShapes" disabled=true>edit shapes</button>
    <button onclick="clearPoints()" id="clearPoints" disabled=true>clear points</button>
    <button onClick="addLink()" id="addLink">add link</button>
    <button onclick="toggleGuides()" id="toggleGuides">hide guides</button>
    <div id="shapeEditor" style="display: none;">
      <label for="nearScale">near scale</label>
      <input type="number" id="nearScale" onchange="nearScaleChanged(this);"></input>
      <label for="farScale">far scale</label>
      <input type="number" id="farScale" onchange="farScaleChanged(this);"></input>
      <label for="floorOrMask">floor or mask</label>
      <select id="floorOrMask" onchange="floorOrMaskChanged(this)">
        <option value="floor">floor</option>
        <option value="mask">mask</option>
      </select>
      <button disabled=true id="saveScales" onclick="saveScales()">save</button>
    </div>
  </div>
  <canvas id="canvas" style="z-index: 0; position: relative; background-color:blue;">
  </canvas>
  <script type="text/javascript">
    const canvas = document.getElementById("canvas");
    const points = [];
    const shapes = [];
    const characters = [];
    const interactables = []; // LINKS, IMAGES, TEXT, VIDEO
    const masks = [];
    const keys = {
      up: false,
      down: false,
      left: false,
      right: false
    };
    const imgs = [new Image(), new Image(), new Image()];

    const backgroundImage = new Image();
    const backgroundWidth = 0;
    const backgroundHeight = 0;

    let showGuides = true;
    let scale = 1.0;
    let mouseX = 0;
    let mouseY = 0;
    let placingCharacter = false;
    let makingShapes = true;
    let maskSecondPoint = null;
    let editingShapes = false;
    let currentEditingShape;
    let idealPlacingWidth;
    let idealPlacingHeight;

    function saveScales() {
      if (editingShapes && currentEditingShape) {
        currentEditingShape.nearScale = parseFloat(document.querySelector("#nearScale").value);
        currentEditingShape.farScale = parseFloat(document.querySelector("#farScale").value);

        let floorOrMaskSelectValue = document.querySelector("#floorOrMask").value;

        if (floorOrMaskSelectValue != currentEditingShape.floorOrMask) {
          currentEditingShape.floorOrMask = floorOrMaskSelectValue;

          if (floorOrMaskSelectValue == 'floor') {
            currentEditingShape.tiles = null;
          } else {
            currentEditingShape.tiles = tileMask(currentEditingShape);
          }
        }

        document.querySelector('#saveScales').disabled = true;
        draw();
      }
    }

    function clearEditValues() {
      currentEditingShape = null;
      document.querySelector("#nearScale").value = null;
      document.querySelector("#farScale").value = null;
      document.querySelector("#floorOrMask").selectedIndex = -1;
      document.querySelector('#saveScales').disabled = true;
    }

    function floorOrMaskChanged(elem) {
      if (editingShapes && currentEditingShape && elem.value != currentEditingShape.floorOrMask) {
        document.querySelector('#saveScales').disabled = false;
      }
    }

    function nearScaleChanged(elem) {
      if (editingShapes && currentEditingShape && elem.value != currentEditingShape.nearScale) {
        document.querySelector('#saveScales').disabled = false;
      }
    }

    function farScaleChanged(elem) {
      if (editingShapes && currentEditingShape && elem.value != currentEditingShape.farScale) {
        document.querySelector('#saveScales').disabled = false;
      }
    }

    canvas.onclick = function(e) {
      if (editingShapes) {
        shapes.every(function(shape) {
          if (adaptedPointIsInPolygon({x: e.clientX, y: e.clientY }, shape.points)) {
            document.querySelector("#nearScale").value = shape.nearScale;
            document.querySelector("#farScale").value = shape.farScale;
            document.querySelector("#floorOrMask").value = shape.floorOrMask;
            currentEditingShape = shape;

            return false;
          } else {
            return true;
          }
        });
      } else if (placingCharacter) {
        shapes.every(function(shape) {
          if (adaptedPointIsInPolygon({x: e.clientX, y: e.clientY }, shape.points)) {
            let width = idealPlacingWidth;
            let height = idealPlacingHeight;

            if (!width || !height) {
              let imageScale = 0;
              let idealSize;
              
              if (backgroundImage.naturalWidth > backgroundImage.naturalHeight) {
                idealSize = backgroundImage.naturalWidth * .1;
              } else {
                idealSize = backgroundImage.naturalHeight * .1;
              }

              if (imgs[0].naturalWidth > imgs[0].naturalHeight) {
                imageScale = idealSize / imgs[0].naturalWidth;
              } else {
                imageScale = idealSize / imgs[0].naturalHeight;
              }

              width = imgs[0].naturalWidth * imageScale;
              height = imgs[0].naturalHeight * imageScale;
            }

	          characters.push({
              images: imgs,
              xp: e.clientX / scaledImageWidth(),
              yp: e.clientY / scaledImageHeight(),
              width: width,
              height: height,
              shape: shape,
              flip: false,
              frame: 0
            })

            idealPlacingWidth = null;
            idealPlacingHeight = null;
            canvas.onmousemove = null;

            makeShapes();

            return false;
          } else {
            return true;
          }
        });
      } else if (makingShapes) {
        if (points.length > 0) {
	        let x = e.clientX;
          let y = e.clientY;

          if (points[0].x - 5 <= x &&
            points[0].x + 5 >= x &&
            points[0].y - 5 <= y &&
            points[0].y + 5 >= y) {

            let sortedPoints = [...points].sort(function(a, b) {
	            if (a.y < b.y) {
                return -1;
              } else if (a.y > b.y) {
                return 1;
              } else {
                return 0;
              }
            });

            shapes.push({
              nearScale: 1.0,
              farScale: 0.5,
              points: points.splice(0, points.length).map(function(point) { return {xp: point.x / scaledImageWidth(), yp: point.y / scaledImageHeight()}; }),
              minYP: sortedPoints[0].y / scaledImageHeight(),
              maxYP: sortedPoints[sortedPoints.length - 1].y / scaledImageHeight(),
              floorOrMask: 'floor'
            });

            document.getElementById("placeCharacter").disabled = false
            document.getElementById("editShapes").disabled = false
          } else {
            points.push({x: e.clientX, y: e.clientY});
          }
        } else {
          points.push({x: e.clientX, y: e.clientY});
          document.getElementById("clearPoints").disabled = false
	      }
      }

      draw();
    }

    function scaledImageWidth() {
      return backgroundImage.naturalWidth * scale;
    }

    function scaledImageHeight() {
      return backgroundImage.naturalHeight * scale;
    }

    function addLink() {
    }

    function makeShapes() {
      placingCharacter = false;
      makingShapes = true;
      editingShapes = false;

      clearEditValues();

      document.getElementById("placeCharacter").disabled = false;
      document.getElementById("makeShapes").disabled = true;

      if (shapes.length > 0) {
        document.getElementById("editShapes").disabled = false;
      }

      document.getElementById("shapeEditor").style.display = "none";

      points.splice(0, points.length);

      draw();
    }

    function placeCharacter() {
      placingCharacter = true;
      makingShapes = false;
      editingShapes = false;

      clearEditValues();

      document.getElementById("placeCharacter").disabled = true;
      document.getElementById("makeShapes").disabled = false;

      if (shapes.length > 0) {
        document.getElementById("editShapes").disabled = false;
      }

      document.getElementById("shapeEditor").style.display = "none";

      canvas.onmousemove = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
        draw();
      }

      draw();
    }

    function editShapes() {
      placingCharacter = false;
      makingShapes = false;
      editingShapes = true;

      clearEditValues();

      document.getElementById("placeCharacter").disabled = false;
      document.getElementById("makeShapes").disabled = false;
      document.getElementById("editShapes").disabled = true;
      document.getElementById("shapeEditor").style.display = "block";

      canvas.onmousemove = null;

      draw()
    }

    function clearPoints() {
      points.splice(0, points.length);
      document.getElementById("clearPoints").disabled = true
      document.getElementById("shapeEditor").style.display = "none";

      clearEditValues();

      makeShapes();

      draw();
    }

    function toggleGuides() {
      if (showGuides) {
        document.getElementById("placeCharacter").style.display = "none";
        document.getElementById("makeShapes").style.display = "none";
        document.getElementById("editShapes").style.display = "none";
        document.getElementById("shapeEditor").style.display = "none";
        document.getElementById("clearPoints").style.display = "none";
        document.getElementById("toggleGuides").innerText = "show guides";
        showGuides = false;
        draw();
      } else {    
        document.getElementById("placeCharacter").style.display = "block";
        document.getElementById("makeShapes").style.display = "block";
        document.getElementById("editShapes").style.display = "block";
        document.getElementById("clearPoints").style.display = "block";
        document.getElementById("shapeEditor").style.display = "none";
        document.getElementById("toggleGuides").innerText = "hide guides";
        showGuides = true;
        makeShapes();
      }
    }

    function resize() {
      canvas.width  = scaledImageWidth();
      canvas.height = scaledImageHeight();
    }

    function draw() {
      let ctx = canvas.getContext("2d");
      let maskDatas = [];

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.drawImage(backgroundImage, 0, 0, scaledImageWidth(), scaledImageHeight());

      if (!showGuides) {
        shapes.filter(function(shape) { return shape.tiles; }).forEach(function(shape) {
          shape.tiles.forEach(function(tile) {
            if (!tile.data) {
              tile.data = ctx.getImageData(tile.x, tile.y, tile.size, tile.size);
            }
          });
        });
      }

      if (showGuides) {
        ctx.fillStyle = "rgba(255, 0, 0, 1.0)";

        if (points.length > 0) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);

          for (let n = 1; n < points.length; n++) {
            ctx.lineTo(points[n].x, points[n].y);
            ctx.stroke();
          }

          for (let n = 0; n < points.length; n++) {
            ctx.beginPath();
            ctx.rect(points[n].x - 2.5, points[n].y - 2.5, 5, 5);
            ctx.fill()
          }
        }

        for (let n = 0; n < shapes.length; n++) {
          ctx.beginPath();

          if (shapes[n].floorOrMask == 'floor') {
            ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
          } else {
            ctx.fillStyle = "rgba(0, 0, 255, 0.5)";
          }

          ctx.moveTo(shapes[n].points[0].xp * scaledImageWidth(), shapes[n].points[0].yp * scaledImageHeight());

          for (let m = 1; m < shapes[n].points.length; m++) {
            ctx.lineTo(shapes[n].points[m].xp * scaledImageWidth(), shapes[n].points[m].yp * scaledImageHeight());
          }

          ctx.fill();
        }

        shapes.filter(function(shape) { return shape.tiles; }).forEach(function(shape) {
          shape.tiles.forEach(function(tile) {
            ctx.beginPath();
            ctx.fillStyle = `rgba(${getRandomInt(256)}, ${getRandomInt(256)}, ${getRandomInt(256)}, 1.0)`;
            ctx.rect(tile.x, tile.y, tile.size, tile.size);
            ctx.fill();
          });
        });
      }

      sortedDrawables().forEach(function(drawable) {
        if (drawable.elem.images) {
          drawImage(
            ctx,
            drawable.elem.images[drawable.elem.frame == 0 ? 0 : (drawable.elem.frame < 3 ? 1 : 2)],
            drawable.x,
            drawable.y,
            drawable.width,
            drawable.height,
            0,
            drawable.elem.flip
          );
        } else if (!showGuides && drawable.elem.tiles) {
          drawable.elem.tiles.forEach(function(tile) {
            ctx.putImageData(tile.data, tile.x, tile.y);
          });
        }
      });

      if (placingCharacter) {
        if (!idealPlacingWidth || !idealPlacingHeight) {
          let imageScale = 0;
          let idealSize;
          
          if (backgroundImage.naturalWidth > backgroundImage.naturalHeight) {
            idealSize = backgroundImage.naturalWidth * .1;
          } else {
            idealSize = backgroundImage.naturalHeight * .1;
          }

          if (imgs[0].naturalWidth > imgs[0].naturalHeight) {
            imageScale = idealSize / imgs[0].naturalWidth;
          } else {
            imageScale = idealSize / imgs[0].naturalHeight;
          }

          idealPlacingWidth = imgs[0].naturalWidth * imageScale;
          idealPlacingHeight = imgs[0].naturalHeight * imageScale;
        }

        ctx.globalAlpha = 0.5;

        drawImage(
          ctx,
          imgs[0],
          mouseX - (idealPlacingWidth / 2),
          mouseY - idealPlacingHeight,
          idealPlacingWidth,
          idealPlacingHeight
        );

        ctx.globalAlpha = 1.0;
      }
    }

    function getRandomInt(max) {
      return Math.floor(Math.random() * max);
    }

    function sortedDrawables() {
      return characters.concat(shapes.filter(function(shape) { return shape.floorOrMask == 'mask'; })).map(function(elem) {
        if (elem.tiles) {
          let sortedTiles = [...elem.tiles].sort(function(a, b) {
              if (a.y + a.size < b.y + b.size) {
                return 1;
              } else if (a.y + a.size > b.y + b.size) {
                return -1;
              } else {
                return 0;
              }
            });
          return {
            elem: elem,
            type: 'mask',
            bottom: sortedTiles[0].y + sortedTiles[0].size
          };
        } else {
          let tScale = ((elem.yp * scaledImageHeight()) - (elem.shape.minYP * scaledImageHeight())) / ((elem.shape.maxYP * scaledImageHeight()) - (elem.shape.minYP * scaledImageHeight())) * (elem.shape.nearScale - elem.shape.farScale) + elem.shape.farScale;

          return {
            elem: elem,
            type: 'character',
            x: (elem.xp * scaledImageWidth()) - ((elem.width / 2) * tScale),
            y: (elem.yp * scaledImageHeight()) - (elem.height * tScale),
            width: elem.width * tScale,
            height: elem.height * tScale,
            bottom: ((elem.yp * scaledImageHeight()) - (elem.height * tScale)) + (elem.height * tScale)
          };
        }
      }).sort(function(a, b) {
        if (a.bottom < b.bottom) {
          return -1;
        } else if (a.bottom > b.bottom) {
          return 1;
        } else {
          return 0;
        }
      });
    }

    function tileMask(mask) {
      let tiles = [];

      let points = mask.points.map(function(point) {
        return {x: point.xp * scaledImageWidth(), y: point.yp * scaledImageHeight()};
      });

      let minX = Math.floor([...points].sort(function(a, b) { return a.x > b.x; })[0].x);
      let minY = Math.floor([...points].sort(function(a, b) { return a.y > b.y; })[0].y);
      let maxX = Math.ceil([...points].sort(function(a, b) { return a.x < b.x; })[0].x);
      let maxY = Math.ceil([...points].sort(function(a, b) { return a.y < b.y; })[0].y);

      let y = minY;
      while (y < maxY) {
        let x = minX;

        while (x < maxX) {
          let square = [
            {x: x, y: y},
            {x: x + 5, y: y},
            {x: x, y: y + 5},
            {x: x + 5, y: y + 5}
          ];

          let isIn = false;
          square.forEach(function (point) {
            if (adaptedPointIsInPolygon(point, mask.points)) {
              isIn = true;
              return false;
            } else {
              return true;
            }
          });

          if (isIn) tiles.push({x: square[0].x, y: square[0].y, size: 5});

          x = x + 5;
        }

        y = y + 5;
      }

      return tiles;
    }

    function pointIsInPolygon(p, polygon) {
      let isInside = false;

      let minX = polygon[0].x, maxX = polygon[0].x;
      let minY = polygon[0].y, maxY = polygon[0].y;

      for (let n = 1; n < polygon.length; n++) {
        let q = polygon[n];
        minX = Math.min(q.x, minX);
        maxX = Math.max(q.x, maxX);
        minY = Math.min(q.y, minY);
        maxY = Math.max(q.y, maxY);
      }

      if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) {
        return false;
      }

      let i = 0, j = polygon.length - 1;
      for (i, j; i < polygon.length; j = i++) {
        if ((polygon[i].y > p.y) != (polygon[j].y > p.y) &&
            p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)
        {
          isInside = !isInside;
        }
      }

      return isInside;
    }

    function adaptedPointIsInPolygon(p, polygon) {
      let adaptedPolygon = polygon.map(function(point) {
        return {x: point.xp * scaledImageWidth(), y: point.yp * scaledImageHeight()};
      });

      return pointIsInPolygon(p, adaptedPolygon);
    }

    window.onresize = function() {
      calculateImageSize();
      resize();
      draw();
    }

    window.onload = function() {
      backgroundImage.onload = function() {
        calculateImageSize();
        resize();
        draw();
      };

      imgs[0].src = "mario0.png";
      imgs[1].src = "mario1.png";
      imgs[2].src = "mario2.png";
      backgroundImage.src = "courtyard.jpeg";
    }

    function calculateImageSize() {
      if (backgroundImage.naturalWidth > backgroundImage.naturalHeight) {
        if (backgroundImage.naturalWidth > window.innerWidth) {
          scale = window.innerWidth / backgroundImage.naturalWidth;

          if (scaledImageHeight() > window.innerHeight) {
            scale = window.innerHeight / backgroundImage.naturalHeight;
          }
        } else if (backgroundImage.naturalHeight > window.innerHeight) {
          scale = window.innerHeight / backgroundImage.naturalHeight;
        } else {
          scale = 1.0;
        }
      } else if (backgroundImage.naturalWidth < backgroundImage.naturalHeight) {
        if (backgroundImage.naturalHeight > window.innerHeight) {
          scale = window.innerHeight / backgroundImage.naturalHeight;

          if (scaledImageWidth() > window.innerWidth) {
            scale = window.innerWidth / backgroundImage.naturalWidth;
          }
        } else if (backgroundImage.naturalWidth > window.innerWidth) {
          scale = window.innerWidth / backgroundImage.naturalWidth;
        } else {
          scale = 1.0;
        }
      } else {
        if (window.innerWidth > window.innerHeight) {
          scale = window.innerHeight / backgroundImage.naturalHeight;
        } else {
          scale = window.innerWidth / backgroundImage.naturalWidth;
        }
      }
    }

    function drawImage(context, image, x, y, width, height, deg, flip, flop, center) {
      context.save();

      if (typeof width === "undefined") width = image.width;
      if (typeof height === "undefined") height = image.height;
      if (typeof center === "undefined") center = false;

      // Set rotation point to center of image, instead of top/left
      if (center) {
        x -= width / 2;
        y -= height / 2;
      }

      // Set the origin to the center of the image
      context.translate(x + width/2, y + height/2);

      // Rotate the canvas around the origin
      var rad = 2 * Math.PI - deg * Math.PI / 180;    
      context.rotate(rad);

      // Flip/flop the canvas
      if (flip) flipScale = -1; else flipScale = 1;
      if (flop) flopScale = -1; else flopScale = 1;
      context.scale(flipScale, flopScale);

      // Draw the image    
      context.drawImage(image, -width/2, -height/2, width, height);

      context.restore();
    }

    const t = setInterval(function() {
      if (characters.length === 0) return;

      let newXP = characters[0].xp;
      let newYP = characters[0].yp;
      let xInc = (5 / scaledImageWidth());
      let yInc = (5 / scaledImageHeight());
      let changed = false;

      if (keys.up) {
        newYP = newYP - yInc;

        maybeAdjustFrame(changed, characters[0]);

        changed = true;
      } else {
        keys.up = false;
      }

      if (keys.down) {
        newYP = newYP + yInc;

        maybeAdjustFrame(changed, characters[0]);

        changed = true;
      } else {
        keys.down = false;
      }

      if (keys.left) {
        newXP = newXP - xInc;
        characters[0].flip = false;
        
        maybeAdjustFrame(changed, characters[0]);

        changed = true;
      } else {
        keys.left = false;
      }

      if (keys.right) {
        newXP = newXP + xInc;
        characters[0].flip = true;

        maybeAdjustFrame(changed, characters[0]);

        changed = true;
      } else {
        keys.right = false;
      }

      if (changed) {
        let xShape, yShape;

        shapes.filter(function(shape) { return shape.floorOrMask == 'floor'; }).every(function(shape) {
          if (adaptedPointIsInPolygon({x: newXP * scaledImageWidth(), y: characters[0].yp * scaledImageHeight()}, shape.points)) {
            xShape = shape;

            if (xShape && yShape) return false;
          }

          if (adaptedPointIsInPolygon({x: characters[0].xp * scaledImageWidth(), y: newYP * scaledImageHeight()}, shape.points)) {
            yShape = shape;

            if (xShape && yShape) return false;
          }

          return true;
        });

        if (xShape) characters[0].xp = newXP;

        if (yShape) characters[0].yp = newYP;

        if (xShape && yShape && xShape == yShape && xShape != characters[0].shape) {
          characters[0].shape = xShape;
        }
      } else {
        characters[0].frame = 0;
      }

      draw();
    }, 50);

    function maybeAdjustFrame(changed, character) {
      if (!changed) {
        character.frame++;
        if (character.frame == 5) character.frame = 1;
      }
    }

    document.addEventListener("keydown", function(e) {
      switch(e.key) {
        case "w":
        case "W":
          keys.up = true;
          break;
        case "a":
        case "A":
          keys.left = true;
          break;
        case "s":
        case "S":
          keys.down = true;
          break;
        case "d":
        case "D":
          keys.right = true;
          break;
      };
    });

    document.addEventListener("keyup", function(e) {
      switch(e.key) {
        case "w":
        case "W":
          keys.up = false;
          break;
        case "a":
        case "A":
          keys.left = false;
          break;
        case "s":
        case "S":
          keys.down = false;
          break;
        case "d":
        case "D":
          keys.right = false;
          break;
      };
    });
  </script>
</body>
</html>
